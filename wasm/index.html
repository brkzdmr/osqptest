<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSQP Webassembly Example</title>
</head>
<body>
<h1>OSQP Webassembly Example</h1>
m <input type="text" id="m" value="3"><br/>
n <input type="text" id="n" value="2"><br/>
P_nnz <input type="text" id="p_nnz" value="3"><br/>
P_x <input type="text" id="p_x" value="4.0, 1.0, 2.0"><br/>
P_i <input type="text" id="p_i" value="0, 0, 1"><br/>
P_p <input type="text" id="p_p" value="0, 1, 3"><br/>
q <input type="text" id="q" value="1.0, 1.0"><br/>
A_nnz <input type="text" id="a_nnz" value="4"><br/>
A_x <input type="text" id="a_x" value="1.0, 1.0, 1.0, 1.0"><br/>
A_i <input type="text" id="a_i" value="0, 1, 0, 2"><br/>
A_p <input type="text" id="a_p" value="0, 2, 4"><br/>
l <input type="text" id="l" value="1.0, 0.0, 0.0"><br/>
u <input type="text" id="u" value="1.0, 0.7, 0.7"><br/>

<button id="runButton">Run</button>

<p id="result"></p>

<!-- Include the generated add_wasm.js script (generated by Emscripten) -->
<script src="build/out/osqp_simple_demo_emscripten.js"></script>

<script>
    // Wait for the WebAssembly module to be fully initialized
    Module.onRuntimeInitialized = function() {
        console.log("WebAssembly loaded successfully.");

        const runButton = document.getElementById('runButton');
        const resultElement = document.getElementById('result');

        // When the button is clicked, process the input
        runButton.addEventListener('click', function() {

            const m = parseInt(document.getElementById('m').value.trim());
            const n = parseInt(document.getElementById('n').value.trim());
            const p_nnz = parseInt(document.getElementById('p_nnz').value.trim());
            const p_x = document.getElementById('p_x').value.trim().split(',').map(x => parseInt(x.trim()));
            const p_i = document.getElementById('p_i').value.trim().split(',').map(x => parseInt(x.trim()));
            const p_p = document.getElementById('p_p').value.trim().split(',').map(x => parseInt(x.trim()));
            const q = document.getElementById('q').value.trim().split(',').map(x => parseInt(x.trim()));
            const a_nnz = parseInt(document.getElementById('a_nnz').value.trim());
            const a_x = document.getElementById('a_x').value.trim().split(',').map(x => parseInt(x.trim()));
            const a_i = document.getElementById('a_i').value.trim().split(',').map(x => parseInt(x.trim()));
            const a_p = document.getElementById('a_p').value.trim().split(',').map(x => parseInt(x.trim()));
            const l = document.getElementById('l').value.trim().split(',').map(x => parseInt(x.trim()));
            const u = document.getElementById('u').value.trim().split(',').map(x => parseInt(x.trim()));

            const p_x_array = new Float32Array(p_x);
            const p_x_ptr = Module._malloc(p_x_array.length * p_x_array.BYTES_PER_ELEMENT);
            Module.HEAPF32.set(p_x_array, p_x_ptr / Float32Array.BYTES_PER_ELEMENT);

            const p_i_array = new Int32Array(p_i);
            const p_i_ptr = Module._malloc(p_i_array.length * p_i_array.BYTES_PER_ELEMENT);
            Module.HEAP32.set(p_i_array, p_i_ptr / Int32Array.BYTES_PER_ELEMENT);

            const p_p_array = new Int32Array(p_p);
            const p_p_ptr = Module._malloc(p_p_array.length * p_p_array.BYTES_PER_ELEMENT);
            Module.HEAP32.set(p_p_array, p_p_ptr / Int32Array.BYTES_PER_ELEMENT);

            const q_array = new Int32Array(q);
            const q_ptr = Module._malloc(q_array.length * q_array.BYTES_PER_ELEMENT);
            Module.HEAP32.set(q_array, q_ptr / Int32Array.BYTES_PER_ELEMENT);

            const a_x_array = new Float32Array(a_x);
            const a_x_ptr = Module._malloc(a_x_array.length * a_x_array.BYTES_PER_ELEMENT);
            Module.HEAPF32.set(a_x_array, a_x_ptr / Float32Array.BYTES_PER_ELEMENT);

            const a_i_array = new Int32Array(a_i);
            const a_i_ptr = Module._malloc(a_i_array.length * a_i_array.BYTES_PER_ELEMENT);
            Module.HEAP32.set(a_i_array, a_i_ptr / Int32Array.BYTES_PER_ELEMENT);

            const a_p_array = new Int32Array(a_p);
            const a_p_ptr = Module._malloc(a_p_array.length * a_p_array.BYTES_PER_ELEMENT);
            Module.HEAP32.set(a_p_array, a_p_ptr / Int32Array.BYTES_PER_ELEMENT);

            const l_array = new Int32Array(l);
            const l_ptr = Module._malloc(l_array.length * l_array.BYTES_PER_ELEMENT);
            Module.HEAP32.set(l_array, l_ptr / Int32Array.BYTES_PER_ELEMENT);

            const u_array = new Int32Array(u);
            const u_ptr = Module._malloc(u_array.length * u_array.BYTES_PER_ELEMENT);
            Module.HEAP32.set(u_array, u_ptr / Int32Array.BYTES_PER_ELEMENT);

            // Call the WebAssembly function and pass the pointer to the array
            const result = Module._main_solve(
                m,
                n,
                p_x_ptr,
                p_i_ptr,
                p_p_ptr,
                p_nnz,
                q_ptr,
                a_x_ptr,
                a_i_ptr,
                a_p_ptr,
                a_nnz,
                l_ptr,
                u_ptr);
            resultElement.textContent = "Result: " + result;

            Module._free(p_x_ptr);
            Module._free(p_i_ptr);
            Module._free(p_p_ptr);
            Module._free(q_ptr);
            Module._free(a_x_ptr);
            Module._free(a_i_ptr);
            Module._free(a_p_ptr);
            Module._free(l_ptr);
            Module._free(u_ptr);
        });

    };
</script>
</body>
</html>
